Вариант 1: Deadlock (смерть от голода)
В данном варианте каждый философ сначала берёт свою левую вилку и ждёт, пока освободится правая. Это приводит к ситуации, когда все философы одновременно держат свои левые вилки и ждут правых, что вызывает взаимную блокировку. Основной механизм, используемый в этом варианте, — это захват ресурсов (вилок) без освобождения до тех пор, пока не будут захвачены оба ресурса.
Используемые механизмы:
Потоки (threads) для моделирования философов.
Мьютексы (mutexes) для синхронизации доступа к вилкам.

Вариант 2: Life-lock (смерть от физической работы)
В этом варианте философы также сначала берут свою левую вилку. Если правая вилка занята, они кладут левую вилку обратно и повторяют попытку взять обе вилки. Это приводит к бесконечному циклу, когда философы постоянно берут и кладут свои левые вилки, так и не добираясь до еды. Здесь основной механизм заключается в попытке захвата ресурса с последующим освобождением в случае неудачи.
Используемые механизмы:
Потоки (threads) для моделирования философов.
Мьютексы (mutexes) для синхронизации доступа к вилкам.
Метод try_lock для проверки возможности захвата мьютекса.

Вариант 3: Корректное взаимодействие (наконец-то он нормально поел)
В этом варианте используется правильное взаимодействие, которое предотвращает взаимную блокировку. Философы пытаются взять обе вилки одновременно, используя механизм std::lock для одновременного захвата двух мьютексов. Это гарантирует, что философ либо захватит обе вилки, либо не захватит ни одной, избегая тем самым взаимных блокировок.
Используемые механизмы:
Потоки (threads) для моделирования философов.
Мьютексы (mutexes) для синхронизации доступа к вилкам.
std::unique_lock и std::lock для одновременного захвата нескольких мьютексов.
