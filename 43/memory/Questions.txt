1. Каков размер виртуальной памяти процесса, как делится пространство процесса между приложением и операционной системой?
Размер виртуальной памяти процесса в 32-разрядной системе составляет 4 ГБ. Обычно 2 ГБ из этого объема выделяется для приложения,
а оставшиеся 2 ГБ резервируются операционной системой для собственных нужд, таких как ядро ОС, драйверы и системные службы. В 64-разрядных системах адресное пространство значительно больше, что позволяет выделять гораздо большие объемы памяти для приложений.

2. Какие разделы есть в адресном пространстве процесса?
Адресное пространство процесса делится на несколько разделов:

Стек (Stack): Используется для хранения данных вызовов функций, локальных переменных и управления потоком выполнения.
Куча (Heap): Используется для динамического выделения памяти в ходе выполнения программы.
Код (Code): Содержит исполняемый код программы.
Данные (Data): Включает в себя глобальные и статические переменные.
Свободное пространство: Память, которая еще не была выделена ни под какие нужды.

3. Что называется резервированием памяти и передачей памяти?
Резервирование памяти (Memory Reservation): Это процесс выделения виртуального адресного пространства для последующего использования, но без фактического выделения физических страниц памяти.
Передача памяти (Memory Commit): Это процесс, при котором зарезервированное адресное пространство связывается с физическими страницами памяти, делая их доступными для использования.

4. Что такое грануляция памяти?
Грануляция памяти (Memory Granularity) — это минимальный размер блока памяти, который может быть выделен или освобожден системой.
В Windows этот размер определяется размером страницы памяти, который обычно составляет 4 КБ.

5. В чем разница между регионом памяти и блоком памяти?
Регион памяти (Memory Region): Это непрерывная область виртуального адресного пространства, которая имеет одинаковые атрибуты защиты и состояния.
Блок памяти (Memory Block): Это меньший участок памяти внутри региона, который может быть выделен или освобожден независимо.

6. Назовите атрибуты защиты блока памяти, поясните их.
Атрибуты защиты блока памяти включают:

PAGE_NOACCESS: Нет доступа.
PAGE_READONLY: Только чтение.
PAGE_READWRITE: Чтение и запись.
PAGE_WRITECOPY: Копирование при записи.
PAGE_EXECUTE: Только выполнение.
PAGE_EXECUTE_READ: Выполнение и чтение.
PAGE_EXECUTE_READWRITE: Выполнение, чтение и запись.
PAGE_EXECUTE_WRITECOPY: Выполнение и копирование при записи.
7. Назовите флаги атрибутов защиты блока, поясните их.
Флаги атрибутов защиты блока включают те же значения, что и атрибуты защиты:

PAGE_NOACCESS
PAGE_READONLY
PAGE_READWRITE
PAGE_WRITECOPY
PAGE_EXECUTE
PAGE_EXECUTE_READ
PAGE_EXECUTE_READWRITE
PAGE_EXECUTE_WRITECOPY
Эти флаги определяют, каким образом может быть использован данный участок памяти.

8. Назовите статусы памяти блоков, поясните их.
Статусы памяти блоков:

MEM_FREE: Блок свободен и не выделен.
MEM_RESERVE: Блок зарезервирован, но физическая память не выделена.
MEM_COMMIT: Блок выделен и привязан к физической памяти.

9. Назовите типы памяти блоков, поясните их.
Типы памяти блоков:

MEM_IMAGE: Память, используемая для загрузки исполняемого файла или DLL.
MEM_MAPPED: Память, сопоставленная с файлом.
MEM_PRIVATE: Приватная память, используемая только этим процессом.

10. Какова последовательность работы с проекцией файла?
Создание или открытие файла с помощью функции CreateFile.
Создание проекции файла с помощью функции CreateFileMapping.
Отображение файла в адресное пространство процесса с помощью функции MapViewOfFile.
Использование отображенной памяти для чтения или записи данных.
Освобождение отображения с помощью функции UnmapViewOfFile.
Закрытие дескрипторов проекции и файла с помощью функций CloseHandle.

11. Как задается размер файла при проецировании?
Размер файла при проецировании задается при создании проекции файла функцией CreateFileMapping,
где указывается максимальный размер проекции. Этот размер может превышать текущий размер файла, что позволяет расширять файл по мере необходимости.

12. Что необходимо для взаимодействия процессов через проекцию?
Для взаимодействия процессов через проекцию файла необходимо:

Оба процесса должны иметь доступ к одному и тому же файлу на диске.
Оба процесса должны создать проекцию файла с помощью CreateFileMapping.
Процессы должны отобразить файл в свое адресное пространство с помощью MapViewOfFile.
Обеспечение синхронизации доступа к памяти, например, через объекты синхронизации (мьютексы, события и т.д.).

13. Назовите 4 причины создания дополнительных куч процесса.
Улучшение производительности путем распределения различных типов данных по разным кучам.
Уменьшение фрагментации памяти.
Обеспечение безопасности путем изоляции критичных данных в отдельной куче.
Управление временем жизни объектов путем создания специализированных куч для временных или долгоживущих объектов.
